import * as THREE from 'three';

/**
 * BoatDynamics class responsible for boat physics and state
 */
class BoatDynamics {
    constructor(world, options = {}) {
        this.world = world;
        
        // Initialize state
        this.initState(options);
    }
    
    /**
     * Initialize boat state with default or custom values
     */
    initState(options = {}) {
        // Core state
        this.position = new THREE.Vector3(0, 0, 0);
        this.rotation = Math.PI / 2;  // Start facing east
        this.speed = 0;
        this.sailAngle = 0;
        this.rudderAngle = 0;
        this.heelAngle = 0;
        
        // Physics properties - use options with defaults
        this.mass = options.mass || 1000;
        this.dragCoefficient = options.dragCoefficient || 0.05;
        this.sailEfficiency = options.sailEfficiency || 1.0;
        this.rudderEfficiency = options.rudderEfficiency || 40.0;
        this.inertia = options.inertia || 500;
        this.heelFactor = options.heelFactor || 0.08;
        this.heelRecoveryRate = options.heelRecoveryRate || 0.5;
        
        // Limits
        this.maxSailAngle = Math.PI / 2;
        this.maxRudderAngle = Math.PI / 4;
        this.maxHeelAngle = Math.PI / 6;
        
        // Force vectors
        this.sailForce = new THREE.Vector3();
        this.forwardForce = new THREE.Vector3();
        this.lateralForce = new THREE.Vector3();
    }
    
    /**
     * Get direction vector based on angle
     * @param {number} angle - The angle in radians
     * @returns {THREE.Vector3} Direction vector
     */
    getDirectionVector(angle) {
        return new THREE.Vector3(
            Math.sin(angle),
            0,
            Math.cos(angle)
        );
    }
    
    /**
     * Set the sail angle
     * @param {number} angle - The sail angle in radians
     */
    setSailAngle(angle) {
        // Get current wind direction
        const windDirection = this.world.getWindDirection().clone();
        const boatDirection = this.getDirectionVector(this.rotation);
        
        // Determine if wind is coming from the left or right of the boat
        const windCrossBoat = new THREE.Vector3().crossVectors(boatDirection, windDirection);
        const windFromLeftSide = windCrossBoat.y > 0;
        const windFromRightSide = windCrossBoat.y < 0;
        
        // Define minimum sail angle offset from center (in radians)
        // This prevents the sail from reaching exactly center
        const minSailOffset = 0.05; // About 3 degrees
        
        // Constrain sail angle based on wind direction
        // If wind from left side, sail cannot go past center to the left (can't go below minSailOffset)
        // If wind from right side, sail cannot go past center to the right (can't go above -minSailOffset)
        let constrainedAngle = angle;
        if (windFromLeftSide && angle > -minSailOffset) {
            constrainedAngle = -minSailOffset;
        } else if (windFromRightSide && angle < minSailOffset) {
            constrainedAngle = minSailOffset;
        }
        
        // Apply normal bounds for sail angle
        this.sailAngle = Math.max(-this.maxSailAngle, Math.min(this.maxSailAngle, constrainedAngle));
    }
    
    /**
     * Set the rudder angle
     * @param {number} angle - The rudder angle in radians
     */
    setRudderAngle(angle) {
        this.rudderAngle = Math.max(-this.maxRudderAngle, Math.min(this.maxRudderAngle, angle));
    }
    
    /**
     * Calculate the force generated by the sail based on wind
     * @returns {THREE.Vector3} The force vector generated by the sail
     */
    calculateSailForce() {
        const windDirection = this.world.getWindDirection().clone();
        const windStrength = this.world.getWindSpeed();
        
        if (windStrength <= 0) {
            return new THREE.Vector3();
        }
        
        // Calculate sail direction and normal vectors
        const sailDirection = this.getDirectionVector(this.rotation + this.sailAngle);
        const sailNormal = this.getDirectionVector(this.rotation + this.sailAngle + Math.PI/2);
        
        // Get boat direction
        const boatDirection = this.getDirectionVector(this.rotation);
        
        // Calculate the vector representing from which side the wind is hitting the sail
        // Use cross product: positive Y means wind is from left side of sail
        const windCrossSail = new THREE.Vector3().crossVectors(sailDirection, windDirection);
        
        // Calculate sign of sail angle to determine sail side
        // Positive means sail is on port/left side, negative means starboard/right side
        const sailSide = Math.sign(this.sailAngle);
        
        // Sail directionality factor
        // When windCrossSail.y and sailSide have opposite signs, wind is hitting the sail from the proper side
        // When they have the same sign, force should be zero
        const windSailFactor = Math.max(0, -sailSide * Math.sign(windCrossSail.y));
        
        // Calculate dot product for wind-sail angle
        const dotProduct = windDirection.dot(sailDirection);
        const angle = Math.acos(Math.min(Math.max(dotProduct, -1), 1));
        
        // Force is maximum when wind is perpendicular to sail and coming from the correct side
        const forceMagnitude = Math.sin(angle) * windStrength * this.sailEfficiency * windSailFactor;
        
        // Determine force direction based on which side wind hits sail
        const forceDirection = windCrossSail.y > 0 ? sailNormal.clone() : sailNormal.clone().negate();
        
        return forceDirection.multiplyScalar(forceMagnitude);
    }
    
    /**
     * Split the sail force into forward and lateral components
     * @param {THREE.Vector3} sailForce - The sail force vector
     */
    splitSailForce(sailForce) {
        const forwardDirection = this.getDirectionVector(this.rotation);
        
        // Project sail force onto forward direction
        const forwardComponent = sailForce.clone().projectOnVector(forwardDirection);
        
        // Only apply forward force if positive (prevents backward motion)
        const forwardDot = forwardComponent.dot(forwardDirection);
        this.forwardForce = forwardDot > 0 ? forwardComponent : new THREE.Vector3();
        
        // Calculate lateral force
        this.lateralForce = sailForce.clone().sub(this.forwardForce);
    }
    
    /**
     * Apply rudder effect to change boat heading
     * @param {number} deltaTime - Time since last update in seconds
     */
    applyRudderEffect(deltaTime) {
        // Calculate speed factor that affects turning rate
        const minSpeedFactor = 0.5;
        const speedFactor = minSpeedFactor + (this.speed * 0.5);
        
        // Calculate turn rate (negative rudder turns right)
        const turnRate = -1 * this.rudderAngle * speedFactor * this.rudderEfficiency / this.inertia;
        
        // Apply turn rate to rotation
        this.rotation += turnRate * deltaTime;
        
        // Normalize rotation to 0-2π range
        this.rotation = this.rotation % (Math.PI * 2);
        if (this.rotation < 0) this.rotation += Math.PI * 2;
    }
    
    /**
     * Calculate the current drag force vector
     * @returns {THREE.Vector3} The drag force vector
     */
    calculateDragForce() {
        // Standard quadratic drag model (proportional to v²)
        const dragMagnitude = this.dragCoefficient * this.speed * this.speed * this.speed;
        
        // Drag always opposes motion, so it's in the opposite direction of travel
        const boatDirection = this.getDirectionVector(this.rotation);
        
        // Return the drag force vector (negative because it opposes motion)
        return boatDirection.clone().multiplyScalar(-dragMagnitude);
    }
    
    /**
     * Calculate and apply heel angle
     * @param {number} deltaTime - Time since last update in seconds
     */
    updateHeelAngle(deltaTime) {
        const lateralMagnitude = this.lateralForce.length();
        
        // Get lateral direction for determining heel direction
        const lateralDirection = new THREE.Vector3(
            -Math.cos(this.rotation), 
            0, 
            Math.sin(this.rotation)
        );
        
        const heelDirection = Math.sign(this.lateralForce.dot(lateralDirection));
        
        // Calculate target heel angle based on lateral force
        const targetHeelAngle = Math.min(
            this.maxHeelAngle,
            lateralMagnitude * this.heelFactor
        ) * heelDirection;
        
        // Smoothly transition to target heel angle
        this.heelAngle += (targetHeelAngle - this.heelAngle) * 
            Math.min(1, deltaTime * this.heelRecoveryRate);
    }
    
    /**
     * Update the boat physics
     * @param {number} deltaTime - Time since last update in seconds
     */
    update(deltaTime) {
        // Ensure deltaTime is reasonable
        const clampedDeltaTime = Math.min(deltaTime, 0.1);
        
        // Calculate forces
        this.sailForce = this.calculateSailForce();
        this.splitSailForce(this.sailForce);
        
        // Get the drag force as a vector
        const dragForceVector = this.calculateDragForce();
        // Extract just the magnitude (negative value)
        const dragForce = dragForceVector.length() * -1;
        
        // Combine forces to calculate net acceleration
        const forwardForceMagnitude = this.forwardForce.length();
        const netForce = forwardForceMagnitude + dragForce; // Sum of propulsion and drag
        const acceleration = netForce / this.mass;
        
        // Apply acceleration to update speed (always keep speed >= 0)
        this.speed = Math.max(0, this.speed + acceleration * clampedDeltaTime * 10);
        
        // Apply rudder effect
        this.applyRudderEffect(clampedDeltaTime);
        
        // Update position based on speed and direction
        const forwardDir = this.getDirectionVector(this.rotation);
        this.position.add(forwardDir.multiplyScalar(this.speed * clampedDeltaTime));
        
        // Update heel angle
        this.updateHeelAngle(clampedDeltaTime);
    }
    
    /**
     * Get the current state of the boat
     * @returns {Object} The boat state
     */
    getState() {
        return {
            position: this.position.clone(),
            rotation: this.rotation,
            speed: this.speed,
            sailAngle: this.sailAngle,
            rudderAngle: this.rudderAngle,
            heelAngle: this.heelAngle
        };
    }
    
    /**
     * Get the current forces acting on the boat
     * @returns {Object} The force vectors
     */
    getForces() {
        return {
            sailForce: this.sailForce.clone(),
            forwardForce: this.forwardForce.clone(),
            lateralForce: this.lateralForce.clone(),
            dragForce: this.calculateDragForce()
        };
    }
    
    /**
     * Set the boat's speed directly (for testing/initialization only)
     * @param {number} speedInKnots - Speed in knots
     */
    setInitialSpeed(speedInKnots) {
        const knotsToMetersPerSecond = 0.51444;
        this.speed = speedInKnots * knotsToMetersPerSecond;
    }
    
    // ---- Getter methods ----
    
    getPosition() {
        return this.position.clone();
    }
    
    getRotation() {
        return this.rotation;
    }
    
    getSpeedInKnots() {
        return this.speed * 1.94384; // Convert m/s to knots
    }
    
    getHeadingInDegrees() {
        let degrees = (this.rotation * 180 / Math.PI) % 360;
        if (degrees < 0) degrees += 360;
        return degrees;
    }
    
    getHeelAngleInDegrees() {
        return this.heelAngle * (180 / Math.PI);
    }
    
    getSailAngle() {
        return this.sailAngle;
    }
    
    getRudderAngle() {
        return this.rudderAngle;
    }
}

export default BoatDynamics; 